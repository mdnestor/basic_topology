/-

The topology associated to a metric space.

-/

import basic_topology.Metric
import basic_topology.Continuity

variable {X Y D: Type*}

-- definition of an open set in a metric space
-- we will give them the prefix `metric_` since we need these names later
-- note its important that 0 < r in the definition of open set, even though this isnt required to be an open ball.
-- (otherwise every set is trivially open by taking r=0 at every point.)
def metric_open [DistanceSpaceStruct D] (d: X â†’ X â†’ D) (A: Set X): Prop :=
  âˆ€ x âˆˆ A, âˆƒ r, âŠ¥ < r âˆ§ openball d x r âŠ† A

def metric_closed [DistanceSpaceStruct D] (d: X â†’ X â†’ D) (A: Set X): Prop :=
  metric_open d Aá¶œ

def metric_clopen [DistanceSpaceStruct D] (d: X â†’ X â†’ D) (A: Set X): Prop :=
  metric_open d A âˆ§ metric_closed d A

-- The empty set is clopen
theorem metric_empty_clopen [DistanceSpace D] [Nontrivial D] (d: X â†’ X â†’ D): metric_clopen d âˆ… := by
  constructor
  Â· intro _ _
    exists âŠ¥
  Â· intro _ hx
    obtain âŸ¨r, hrâŸ© := exists_ne (âŠ¥: D)
    exists r
    constructor
    Â· simp_all
      exact pos_of_ne_zero hr
    Â· exact fun _ _ => hx

-- If A is clopen then Aá¶œ is clopen
theorem clopen_implies_compl_clopen [DistanceSpaceStruct D] (d: X â†’ X â†’ D) {A: Set X} (h: metric_clopen d A): metric_clopen d Aá¶œ := by
  constructor
  Â· exact h.right
  Â· simp [metric_closed]
    exact h.left

-- A is clopen iff. Aá¶œ is clopen
theorem clopen_iff_compl_clopen [DistanceSpaceStruct D] (d: X â†’ X â†’ D) (A: Set X): metric_clopen d A â†” metric_clopen d Aá¶œ := by
  constructor
  Â· exact clopen_implies_compl_clopen d
  Â· intro h
    rw [â†compl_compl A]
    exact clopen_implies_compl_clopen d h

-- The whole space is clopen
theorem metric_univ_clopen [DistanceSpace D] [Nontrivial D] (d: X â†’ X â†’ D): metric_clopen d Set.univ := by
  rw [â†Set.compl_empty]
  exact (clopen_iff_compl_clopen d âˆ…).mp (metric_empty_clopen d)

-- Open ball is open
-- TODO this needs work since we can't subtract..
theorem openball_open [DistanceSpace D] {d: X â†’ X â†’ D} (hd: IsMetric d) (x: X) (r: D): metric_open d (openball d x r) := by
  intro z hz
  sorry
  -- exists r - d x z
  -- constructor
  -- Â· exact tsub_pos_of_lt hz
  -- Â· exact openball_mem_smaller_ball hd

-- Closed ball is closed
theorem closedball_closed [DistanceSpace D] {d: X â†’ X â†’ D} (hd: IsMetric d) (x: X) (r: D): metric_closed d (closedball d x r) := by
  intro x0 hx0
  sorry
  -- exists d x x0 - r
  -- constructor
  -- Â· simp_all [closedball]
  -- Â· exact closedball_compl_mem hd hx0

-- the set of open balls in a metric space
def openballs [DistanceSpaceStruct D] (d: X â†’ X â†’ D): Family X :=
  â‹ƒ (x: X), â‹ƒ (r: D), {openball d x r}

theorem open_iff_sUnion_of_balls [DistanceSpace D] (d: X â†’ X â†’ D) (hd: IsMetric d) (A: Set X): metric_open d A â†” âˆƒ ğ’° âŠ† openballs d, A = â‹ƒâ‚€ ğ’° := by
  apply Iff.intro
  Â· intro h
    exists fun U => U âŠ† A âˆ§ U âˆˆ openballs d
    constructor
    Â· intro U âŸ¨_, hU2âŸ©
      exact hU2
    Â· ext z
      constructor
      Â· intro hz
        obtain âŸ¨r, hr1, hr2âŸ© := h z hz
        exists openball d z r
        sorry
        -- repeat' constructor
        -- Â· exact hr2
        -- Â· exact z
      Â· intro âŸ¨U, âŸ¨hU1, _âŸ©, hU3âŸ©
        exact hU1 hU3
  Â· intro âŸ¨ğ’°, hğ’°1, hğ’°2âŸ©
    rw [hğ’°2]
    intro z âŸ¨U, hU1, hU2âŸ©
    have := hğ’°1 hU1
    simp_all [openballs]
    obtain âŸ¨x, r, hxâŸ© := this
    sorry
    -- exists r - d x z
    -- constructor
    -- Â· rw [â†hx] at hU2
    --   simp_all [openball]
    -- Â· calc
    --     openball d z (r - d x z)
    --     _ âŠ† openball d x r := openball_mem_smaller_ball hd
    --     _ = U              := hx
    --     _ âŠ† â‹ƒâ‚€ ğ’°          := Set.subset_sUnion_of_subset ğ’° U (fun â¦ƒaâ¦„ a â†¦ a) hU1

-- the set of all open sets in a metric space
def metric_opens [DistanceSpace D] (d: X â†’ X â†’ D): Family X :=
 {A | metric_open d A}

theorem openballs_sub_opens [DistanceSpace D] {d: X â†’ X â†’ D} (hd: IsMetric d): openballs d âŠ† metric_opens d := by
  intro _ hU
  simp_all [openballs]
  obtain âŸ¨x, r, hUâŸ© := hU
  rw [â†hU]
  exact openball_open hd x r

-- Every set is open in the topology generated by the discrete metric.
theorem discrete_opens (X D: Type*) [CompleteDistanceSpace D] [Nontrivial D] [DecidableEq X]: metric_opens (discrete_metric X D) = Set.univ := by
  apply Set.eq_univ_of_univ_subset
  intro A hA x hx
  exists âŠ¤
  constructor
  Â· exact bot_lt_top
  Â· sorry -- simp [discrete_openball_singleton x bot_lt_top]

-- in a metric space, arbitrary unions of open sets are open (doesnt actually depend on d being a metric)
theorem metric_open_sUnion [DistanceSpace D] {d: X â†’ X â†’ D} {C: Family X} (h: C âŠ† metric_opens d): â‹ƒâ‚€ C âˆˆ metric_opens d := by
  intro z âŸ¨U, hU1, hU2âŸ©
  obtain âŸ¨r, hr1, hr2âŸ© := h hU1 z hU2
  exists r
  constructor
  Â· exact hr1
  Â· exact Set.subset_sUnion_of_subset C U hr2 hU1

-- in a metric space, finite intersections of open sets are open
theorem metric_open_finite_sInter [DistanceSpace D] {d: X â†’ X â†’ D} (hd: IsMetric d) {C: Family X} (h1: C âŠ† metric_opens d) (h2: Finite C): â‹‚â‚€ C âˆˆ metric_opens d := by
  intro z hz
  simp at hz

  -- should be able to get a finite set of radii
  sorry


-- in a metric space every open ball of positive radius is a neighborhood
theorem openball_neighborhood [DistanceSpace D] {d: X â†’ X â†’ D} (hd: IsMetric d) (x: X) {r: D} (hr: âŠ¥ < r): neighborhood (metric_opens d) (openball d x r) x := by
  exists openball d x r
  repeat' (apply And.intro)
  Â· apply openballs_sub_opens hd
    simp [openballs]
  Â· exact (openball_mem_iff hd x r).mpr hr
  Â· rfl

-- the opens in a metric space form a topology
theorem metric_opens_is_topology [DistanceSpace D] {d: X â†’ X â†’ D} (hd: IsMetric d): IsTopology (metric_opens d) := {
  sUnion := by intro; exact metric_open_sUnion
  finite_sInter := by intro; exact metric_open_finite_sInter hd
}

-- given a metric on X, put a topology on X
def metric_to_topology [DistanceSpace D] (d: Metric X D): Topology X := {
  Open := metric_opens d.distance
  is_topology := metric_opens_is_topology d.is_metric
}

def MetricSpace.opens [DistanceSpace D] (M: MetricSpace D): Set (Set M.points) :=
  metric_opens M.distance

def metrizable (ğ’¯: Topology X) (D: Type*) [DistanceSpace D]: Prop :=
  âˆƒ d: Metric X D, metric_to_topology d = ğ’¯

-- theorem isometry_homeomorphic_image [DistanceSpace D] {dX: X â†’ X â†’ D} {dY: Y â†’ Y â†’ D} {hX: IsMetric dX} {hY: IsMetric dY} {i: X â†’ Y} (h: isometry dX dY i): homeomorphism (metric_opens dX) (metric_opens (submetric dY (Set.range i))) (Set.rangeFactorization i) := {
--   bijection := by
--     constructor
--     Â· have := isometry_is_injective hX hY i h
--       simp_all [Set.rangeFactorization, Function.Injective]
--       exact this
--     Â· exact Set.rangeFactorization_surjective
--   continuous_forward := sorry
--   continuous_inverse := sorry
-- }

theorem continuous_metric_at_iff [DistanceSpace D] (dX: X â†’ X â†’ D) (dY: Y â†’ Y â†’ D) (f: X â†’ Y) (x: X): continuous_metric_at dX dY f x â†” ContinuousAt (metric_opens dX) (metric_opens dY) f x := by
  sorry

theorem continuous_metric_iff [DistanceSpace D] (dX: X â†’ X â†’ D) (dY: Y â†’ Y â†’ D) (f: X â†’ Y) (x: X): continuous_metric dX dY f â†” Continuous (metric_opens dX) (metric_opens dY) f := by
  sorry
--totally_bounded and complete iff compact--
